1) modules in obsolete are used?

2) Not sure what checkIfToTeleport does. Why does it use the highest K and not the one from the previous step?

3) Moved some code from RandomWalker.one step to Manipulator.randomlyUnfreezeParticle (probability for unfreezing?)

4) There is a lot of stuff going on in randomlyChangeSSOfOneParticle which is not very transparent

5) Bug fix in randomlyChangeBranchingOfPid:
                    self.M.decays[p][dpid]=0. -> self.M.decays[pid][dpid]=0.
                    
6) checkIfToTeleport -> set overall probability?

7) If self.hiscoreList is None -> should always store model, no? (at the end of RandomWalker.onestep)

8) checkIfToTeleport vs decideOnTakingStep?

9) Should we move protomodel.restore() to manipulator (it is used when the step is not taken)? It is a bit awkward to have the model remembering about its past.


10) Maybe ProtoModel should hold BSMlist and a Model obj? This way a freezing/unfreezing corresponding simply to removing/adding particles to the list and the predictor would
be run directly on the Model object, without the need for creating a SLHA as an intermediate.
Or even have ProtoModel being a derived class from Model? -> Don't know if we want the codes to be so tightly coupled though

11) Add parameter cards to control each block?

builder_parameters.ini -> Parameters for computing xsecs (nevents), randomly changing the model (probabilities, sigmas...)
tester_parameters.ini -> essentially the SModelS parameters.ini
walker_parameters.ini -> number of steps,...


12) resolveMuhat -> Should be applied after predict() AND in takeStep()???


---> Move predictor one layer up (just below RandomWalker). So Predictor has access to the protoModel, but not the other way around
        all the model testing related stuff goes up to predictor and moves away from ProtoModel

High complexity methods:

Manipulator.randomlyChangeBranchingOfPid
Manipulator.writeDictFile
