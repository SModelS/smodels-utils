1) modules in obsolete are used?

3) Moved some code from RandomWalker.one step to Manipulator

4) There is a lot of stuff going on in randomlyChangeSSOfOneParticle which is not very transparent

5) Bug fix in randomlyChangeBranchingOfPid:
                    self.M.decays[p][dpid]=0. -> self.M.decays[pid][dpid]=0.
                    
6) checkIfToTeleport -> set overall probability?

7) If self.hiscoreList is None -> should always store model, no? (at the end of RandomWalker.onestep)

9) Should we move protomodel.restore() to manipulator (it is used when the step is not taken)? It is a bit awkward to have the model remembering about its past.

10) Maybe ProtoModel should hold BSMlist and a Model obj? This way a freezing/unfreezing corresponding simply to removing/adding particles to the list and the predictor would
be run directly on the Model object, without the need for creating a SLHA as an intermediate.
Or even have ProtoModel being a derived class from Model? -> Don't know if we want the codes to be so tightly coupled though

11) Add parameter cards to control each block?

builder_parameters.ini -> Parameters for computing xsecs (nevents), randomly changing the model (probabilities, sigmas...)
tester_parameters.ini -> essentially the SModelS parameters.ini
walker_parameters.ini -> number of steps,...

12) resolveMuhat -> Should be applied after predict() AND in takeStep()???

13) What is trimmer used for?

14) We should never have only 1 unfrozen particle (LSP), since it would require mono-jet constraints, which we do not have.

15) Could the "merge particles" be treated as the other random changes in the model? So it always happens independent of
the resulting Z value? The decision to take the step would still be taken according to the Z ratios...
(This would greatly simplify the code)

16) How can particle swaps change the Z-value? I'm not sure why this is checked for.


17) Replace merge particles and swap by "simplify model" as a "parallel step"? And keep the one with highest score?

---> Move predictor one layer up (just below RandomWalker). So Predictor has access to the protoModel, but not the other way around
        all the model testing related stuff goes up to predictor and moves away from ProtoModel

High complexity methods:

Manipulator.randomlyChangeBranchingOfPid
Manipulator.writeDictFile
