    plotableAttr = [] + Orig.infoAttr
    internalAttr = [] + Orig.internalAttr
    
    def __init__(self,name):
        
        """
        :param Name: name as string
        """
        
        Orig.__init__(self,name)
        
    def __iter__(self):
        
        """
        gives the entries of the original efficiency map
        :yield: [x-value in GeV, y-value in GeV,..., efficiency]
        """
        if self.fileType==None:
            raise StopIteration()
        
        for point in getattr(self,self.fileType)():
            if not self._positivValues(point): continue
            if self.percentage:
                point[-1]=point[-1]/100.
            yield point

    def __len__(self):
        """ count how many points """
        x=0
        for point in self:
            if not self._positivValues(point): continue
            x+=1
        return x

    def txt(self):
        
        """
        iterable method
        processing txt-files containing only 3 columns with
        floats. The columns of the file have to contain the values
        for the following variables:
        1. column: x-value in GeV
        2. column: y-value in Gev
	...
        n. column: efficiency
        :raise txtFormatError: if file do not contain the right number of columns 
        :yield: [x-value in GeV, y-value in GeV,... efficiency] 
        """
        
        for point in Orig.txt(self):
            if not len(point) == self._planeDimensions+1:
                Errors().txtFormat(self.path, 'OrigEfficiencyMap', self._planeDimensions+1)
            yield point

    def effi(self):
        
        for point in Orig.effi(self):
            if not len(point) in [3, 4]:
                Errors().effiFormat(self.path, 'OrigEfficiencyMap', 3)
            yield point

    
    def root(self):
        
        """
        iterable method
        processing root-files containing root 2D-histograms
        The bins of the histograms have to contain the
        efficiencies; unit of x and y-axis: GeV
        :yield: [x-value in GeV, y-value in GeV,..., efficiency]
        """
        
        limit = Orig.root(self)
        for point in self._getPoints(limit):
            yield point
                
    def cMacro(self):
        
        """
        iterable method
        processing root c-macros containing root 2D-histograms
        The bins of the histograms have to contain the 
        efficiencies; unit of x and y-axis: GeV
        :yield: [x-value in GeV, y-value in GeV,..., efficiency]
        """
       
        limit = Orig.cMacro(self)
        for point in self._getPoints(limit):
            yield point
            
    def canvas(self):
        
        """
        iterable method
        processing root-files containing ROOT.TCanvas objects
        with 2D-histograms
        The bins of the histograms have to contain the 
        efficiencies; unit of x and y-axis: GeV
        :yield: [x-value, y-value, efficiency]
        """
        
        limit = Orig.canvas(self)
        for point in self._getPoints(limit):
            yield point
                
    def _getPoints(self,limit):
        
        """
        iterable metod
        processing root 2D-histograms
        :param limit: root 2D-histogram
        :yield: [x-axes, y-axes, bin contend]
        """
        
	naxis = self._planeDimensions
        xAxis = limit.GetXaxis()
        yAxis, zAxis = None,None
	if naxis > 1:
            yAxis = limit.GetYaxis()
        if naxis > 2:
            zAxis = limit.GetYaxis()
        xRange = range(1,xAxis.GetNbins() + 1)
	if yAxis:
            yRange = range(1,yAxis.GetNbins() + 1)
        if zAxis:
            zRange = range(1,zAxis.GetNbins() + 1)
        for xBin in xRange:
            x = xAxis.GetBinCenter(xBin)
            if not yAxis: continue
            for yBin in yRange:
                y = yAxis.GetBinCenter(yBin)
                if not zAxis:
                    eff = limit.GetBinContent(xBin, yBin)
                    if eff == 0.: continue
                    yield [x, y, eff]
                else: 
                    for zBin in zRange:
                        eff = limit.GetBinContent(xBin, yBin, zBin)
                        if eff == 0.: continue
                        yield [x, y, z, eff]

